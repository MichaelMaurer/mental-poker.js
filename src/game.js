const Config = require('./config');
const Deck = require('./deck');
const GameState = require('./enums/game-state');
const Player = require('./player');
const Utils = require('./utils');

class Game extends Player {
  constructor(playerCount = 0, ...playerParams) {
    super(...playerParams);

    this.playerCount = playerCount;
    this.turnPlayerIndex = playerCount > 0 ? 0 : -1;
    this.state = GameState.GENERATING_DECK_POINTS;

    this.deckSequence = [];
    this.ownedCardIndexes = [];
    this.cardsOnTable = [];
  }

  getUnownedCardIndexes() {
    return Array.from(new Array(Config.cardsInDeck), (v, i) => i)
      .filter((v) => this.ownedCardIndexes.indexOf(v) < 0);
  }

  getRandomUnownedCardIndex() {
    const unownedCardIndexes = this.getUnownedCardIndexes();

    // Return the index of an unowned card
    return unownedCardIndexes[
      Utils.getRandomInt(0, unownedCardIndexes.length)
    ];
  }

  generateInitialDeck(playersPoints) {
    if (playersPoints) {
      // Generate points based on points generated by each player
      let deckPoints = [];
      do {
        for (const points of playersPoints) {
          deckPoints = points.map((playerPoint, i) => { // eslint-disable-line
            const deckPoint = deckPoints[i];

            // Add the current player's point to the corresponding deck point
            return deckPoint ? playerPoint.add(deckPoint) : playerPoint;
          });
        }
      } while (
        // Avoid duplicate deck points
        (new Set(
          deckPoints.map((point) => point.x.toString(16))
        )).size !== deckPoints.length
      );

      this.deckSequence = [new Deck(deckPoints)];
    } else {
      // Generate points at random
      this.deckSequence = [new Deck(Utils.getRandomPoints())];
    }

    this.state = GameState.SHUFFLING_DECK;
    return this;
  }

  addDeckToSequence(deck) {
    // Disallow modifying deck sequence if the game has already started
    if (this.state >= GameState.PLAYING) {
      return false;
    }

    if (this.turnPlayerIndex + 1 === this.playerCount) {
      // Update game state if necessary
      this.state = this.state === GameState.SHUFFLING_DECK ?
        GameState.LOCKING_DECK :
        GameState.PLAYING;

      this.turnPlayerIndex = 0;
    } else {
      this.turnPlayerIndex += 1;
    }

    this.deckSequence.push(deck);
    return true;
  }

  drawCard(index, secrets) {
    if (this.ownedCardIndexes.indexOf(index) < 0) {
      const pointUnlocked = this.deckLocked.unlockSingle(index, secrets);
      const initialDeckPoints = this.deckSequence[0].points;

      for (let i = initialDeckPoints.length - 1; i >= 0; --i) {
        if (initialDeckPoints[i].eq(pointUnlocked)) {
          this.ownedCardIndexes.push(index);
          return i;
        }
      }
    }

    return -1;
  }

  verify() {
    // TODO
  }
}

module.exports = Game;
