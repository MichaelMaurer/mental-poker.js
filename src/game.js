const Config = require('./config');
const Deck = require('./deck');
const Player = require('./player');
const Utils = require('./utils');

class Game extends Player {
  constructor(...params) {
    super(...params);

    this.deckSequence = [];
    this.ownedCardIndexes = [];
    this.cardsOnTable = [];
  }

  getUnownedCardIndexes() {
    return Array.from(new Array(Config.cardsInDeck), (v, i) => i)
      .filter((v) => this.ownedCardIndexes.indexOf(v) < 0);
  }

  getRandomUnownedCardIndex() {
    const unownedCardIndexes = this.getUnownedCardIndexes();

    // Return the index of an unowned card
    return unownedCardIndexes[
      Utils.getRandomInt(0, unownedCardIndexes.length)
    ];
  }

  generatePoints(playersPoints) {
    if (playersPoints) {
      // Generate points based on points generated by each player
      let deckPoints = [];
      do {
        for (const points of playersPoints) {
          deckPoints = points.map((playerPoint, i) => { // eslint-disable-line
            const deckPoint = deckPoints[i];

            // Add the current player's point to the corresponding deck point
            return deckPoint ? playerPoint.add(deckPoint) : playerPoint;
          });
        }
      } while (
        // Avoid duplicate deck points
        (new Set(
          deckPoints.map((point) => point.x.toString(16))
        )).size !== deckPoints.length
      );

      this.deckSequence.push(new Deck(deckPoints));
    } else {
      // Generate points at random
      this.deckSequence.push(new Deck(Utils.getRandomPoints()));
    }
  }

  drawCard(index, secrets) {
    if (this.ownedCardIndexes.indexOf(index) < 0) {
      const pointUnlocked = this.deckLocked.unlockSingle(index, secrets);
      const originalDeckPoints = this.deckSequence[0].points;

      for (let i = originalDeckPoints.length - 1; i >= 0; --i) {
        if (originalDeckPoints[i].eq(pointUnlocked)) {
          this.ownedCardIndexes.push(index);
          return i;
        }
      }
    }

    return -1;
  }
}

module.exports = Game;
