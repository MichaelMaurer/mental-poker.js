const Config = require('./config');
const Deck = require('./deck');
const GameState = require('./enums/game-state');
const Player = require('./player');
const Utils = require('./utils');

/**
 * A mutable object which serves as an entry point for creating mental poker
 * games.
 */
class Game extends Player {
  /**
   * Number of players in the game. If positive, it makes implementing
   * turn-based behavior easier.
   * @type {number}
   * @member playerCount
   * @memberof Game
   */

  /**
   * Index of the currently acting player in the turn. If `playerCount` is not
   * positive, then returns -1.
   * @type {number}
   * @member turnPlayerIndex
   * @memberof Game
   */

  /**
   * Represents the current state of the game.
   * @type {GameState}
   * @member state
   * @memberof Game
   */

  /**
   * Keeps an ordered list of decks used throughout the game, allowing easy
   * verification at the end of the game.
   * @type {Deck[]}
   * @member deckSequence
   * @memberof Game
   */

  /**
   * Keeps an ordered list of owned card indexes.
   * @type {number[]}
   * @member ownedCardIndexes
   * @memberof Game
   */

  /**
   * Keeps an ordered list of community card IDs.
   * @type {number[]}
   * @member cardsOnTable
   * @memberof Game
   */

  /**
   * @param {Object} params
   * @param {number} params.playerCount
   * @param {Point[]} params.points
   * @param {BigInt[]} params.secrets
   */
  constructor(params) {
    super(params);

    this.playerCount = params.playerCount || 0;
    this.turnPlayerIndex = this.playerCount > 0 ? 0 : -1;
    this.state = GameState.GENERATING_DECK_POINTS;

    this.deckSequence = [];
    this.ownedCardIndexes = [];
    this.cardsOnTable = [];
  }

  /**
   * Returns all card indexes which are not owned.
   * @returns {number[]}
   */
  getUnownedCardIndexes() {
    return Array.from(new Array(Config.cardsInDeck), (v, i) => i)
      .filter((v) => this.ownedCardIndexes.indexOf(v) < 0);
  }

  /**
   * Returns a random unowned card index.
   * @returns {number}
   */
  getRandomUnownedCardIndex() {
    const unownedCardIndexes = this.getUnownedCardIndexes();

    // Return the index of an unowned card
    return unownedCardIndexes[
      Utils.getRandomInt(0, unownedCardIndexes.length)
    ];
  }

  /**
   * Generates the initial deck of the game's deck sequence.
   * @param {?(Point[])} otherPlayersPoints Points of opponents to be used for
   * generating deck points. If omitted, then deck points will be generated at
   * random.
   * @returns {Game}
   */
  generateInitialDeck(otherPlayersPoints) {
    if (otherPlayersPoints) {
      // Generate points based on points generated by each player
      let deckPoints = [];
      do {
        // Combine the points of self with the points of opponents
        for (const playerPoints of [this.points, ...otherPlayersPoints]) {
          deckPoints = playerPoints.map((playerPoint, i) => { // eslint-disable-line
            const deckPoint = deckPoints[i];

            // Add the current player's point to the corresponding deck point
            return deckPoint ? playerPoint.add(deckPoint) : playerPoint;
          });
        }
      } while (
        // Avoid duplicate deck points
        (new Set(
          deckPoints.map((point) => point.x.toString(16))
        )).size !== deckPoints.length
      );

      this.deckSequence = [new Deck(deckPoints)];
    } else {
      // Generate points at random
      this.deckSequence = [new Deck(Utils.getRandomPoints())];
    }

    this.state = GameState.SHUFFLING_DECK;
    return this;
  }

  /**
   * Adds a shuffled or locked deck to the game's deck sequence. Automatically
   * takes turn on behalf of the currently acting player, and updates game state
   * if necessary.
   * @param {Deck} deck
   * @returns {boolean} True if the action was successful.
   */
  addDeckToSequence(deck) {
    // Disallow modifying deck sequence if the game has already started
    if (this.state >= GameState.PLAYING) return false;

    this.deckSequence.push(deck);

    // Update game state if the turn has come to an end
    if (this.takeTurn() === 0) {
      this.state = this.state === GameState.SHUFFLING_DECK ?
        GameState.LOCKING_DECK :
        GameState.PLAYING;
    }

    return true;
  }

  /**
   * Takes turn on behalf of the currently acting player, updating
   * `turnPlayerIndex` if `playerCount` is a positive integer.
   * @returns {number} On success, the index of the next player in turn.
   * Otherwise, -1.
   */
  takeTurn() {
    if (this.playerCount <= 0) return -1;

    this.turnPlayerIndex = (this.turnPlayerIndex + 1) % this.playerCount;
    return this.turnPlayerIndex;
  }

  /**
   * Draws an unowned card at the given index, unlocking it by its corresponding
   * secrets.
   * @param {number} index Index of the card to be drawn.
   * @param {BigInt[]} secrets Secret of each player at the given index.
   * @returns {number} On success, the ID of the drawn card. Otherwise, -1.
   */
  drawCard(index, secrets) {
    if (this.ownedCardIndexes.indexOf(index) < 0) {
      const currentDeck = this.deckSequence[this.deckSequence.length - 1];
      const pointUnlocked = currentDeck.unlockSingle(index, secrets);
      const initialDeckPoints = this.deckSequence[0].points;

      for (let i = initialDeckPoints.length - 1; i >= 0; --i) {
        if (initialDeckPoints[i].eq(pointUnlocked)) {
          this.ownedCardIndexes.push(index);
          return i;
        }
      }
    }

    return -1;
  }

  verify() {
    // TODO
  }
}

module.exports = Game;
