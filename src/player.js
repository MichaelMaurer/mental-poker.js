import Card from './card';
import Config from './config';
import Secret from './secret';
import * as Utils from './utils';
import type { Point } from './interfaces';

/**
 * A mutable object which represents a player of a game.
 * @class Player
 */
export default class Player {
  id: string|number;

  isSelf: boolean;

  /**
   * Points generated by the player.
   */
  points: Point[] = [];

  /**
   * Secrets of the player. Must be kept hidden from others until the end of the
   * game and shall not be modified directly.
   */
  secrets: Secret[] = new Array(Config.cardsInDeck + 1);

  /**
   * Secret hashes of the player. Used for secret verification at the end of the
   * game.
   */
  secretHashes: string[] = [];

  /**
   * List of cards which are in the hand of the player.
   */
  cardsInHand: Card[] = [];

  /**
   * @param {?Object} params Parameters to be assigned to the new instance.
   */
  constructor(params: ?Object) {
    Object.assign(this, params);

    // Auto-generate points and secrets of self
    if (this.isSelf) {
      this.points = Utils.getRandomPoints();
      this.secrets = Utils.getRandomSecrets();
      this.secretHashes = this.secrets.map((secret: Secret): string =>
        secret.getHash()
      );
    }
  }

  /**
   * Adds and verifies a secret at the given index.
   * @param {number} index Index of the secret to be added.
   * @param {Secret} secret Secret to be added.
   * @returns {boolean} Null whether verification has failed, otherwise, a
   * `Player` instance.
   */
  addSecret(index: number, secret: Secret): Player {
    // Avoid re-addition of secrets
    if (this.secrets[index]) return this;

    // Check whether the given secret satisfies its corresponding hash
    if (Utils.getSecretHash(secret) !== this.secretHashes[index]) {
      return null;
    }

    return new this.constructor({
      ...this,
      secrets: [
        this.secrets.slice(0, index - 1),
        secret,
        this.secrets.slice(index + 1),
      ],
    });
  }
}
